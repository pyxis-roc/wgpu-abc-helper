# SPDX-FileCopyrightText: 2024 University of Rochester
#
# SPDX-License-Identifier: MIT
language = "C++"

# REUSE-IgnoreStart
header = "// SPDX-FileCopyrightText: 2024 University of Rochester \n//\n// SPDX-License-Identifier: MIT\n"
# REUSE-IgnoreEnd
pragma_once = true
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
# namespace = "wgpu_constraints"
documentation = true
# no_includes = true
# sys_includes = ["cstdint", "cstdarg"]
namespace = "abc_helper"
include_version = true
usize_is_size_t = true

[export]
# FfiStr and CString are just a wrappers around const char*
# FfiTerm and FfiAbcType should be renamed to Term and AbcType, as they are just FFI interfaces to these types.
rename = { "FfiStr" = "const char*", "CString" = "const char*"}
# renaming_overrides_prefixing = true
exclude = ["WrappedInterval", "Predicate"]

[parse.expand]
crates = ["abc-helper"]
features = ["cffi"]

[enum]
derive_helper_methods = true
derive_const_casts = true

[export.pre_body]
"FfiTerm" = """
  auto get_id() {
    return this->id;
  }
private:
"""
"FfiAbcType" = """
  auto get_id() {
    return this->id;
  }
private:
"""

"FFISummary" = """
  auto get_id() {
    return this->id;
  }
private:
"""

"Context" = """
  auto get_id() {
    return this->id;
  }
private:
"""


[export.body]
"Context" = """
public:
  MaybeTerm new_unit_pred(FfiTerm term);
  MaybeTerm new_literal_true();
  MaybeTerm new_literal_false();
  MaybeTerm new_logical_and(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_logical_or(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_comparison(CmpOp op, FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_not(FfiTerm t);
  MaybeTerm new_var(const char* s);
  MaybeTerm new_cast(FfiTerm source_term, FfiAbcType ty);
  MaybeTerm new_cmp_term(CmpOp op, FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_index_access(FfiTerm base, FfiTerm index);
  MaybeTerm new_struct_access(FfiTerm base, const char* field, FfiAbcType ty, size_t field_idx);
  MaybeTerm new_splat(FfiTerm term, uint32_t size);
  MaybeTerm new_literal(Literal lit);
  MaybeTerm new_binary_op(BinaryOp op, FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_unary_op(UnaryOp op, FfiTerm term);
  MaybeTerm new_max(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_min(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_select(FfiTerm iftrue, FfiTerm iffalse, FfiTerm predicate);
  MaybeTerm new_vec2(FfiTerm term_0, FfiTerm term_1, FfiAbcType ty);
  MaybeTerm new_vec3(FfiTerm term_0, FfiTerm term_1, FfiTerm term_2, FfiAbcType ty);
  MaybeTerm new_vec4(FfiTerm term_0, FfiTerm term_1, FfiTerm term_2, FfiTerm term_3, FfiAbcType ty);
  MaybeTerm new_array_length(FfiTerm term);
  MaybeTerm new_array_store(FfiTerm base, FfiTerm index, FfiTerm value);
  MaybeTerm new_store(FfiTerm base, const char* field, size_t field_idx, FfiTerm value);
  MaybeTerm new_struct_store(FfiTerm base, size_t field_idx, FfiTerm value);
  MaybeTerm new_abs(FfiTerm term);
  MaybeTerm new_pow(FfiTerm base, FfiTerm exponent);
  MaybeTerm new_dot(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_mat2x2(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty);
  MaybeTerm new_mat2x3(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty);
  MaybeTerm new_mat2x4(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty);
  MaybeTerm new_mat3x2(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty);
  MaybeTerm new_mat3x3(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty);
  MaybeTerm new_mat3x4(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty);
  MaybeTerm new_mat4x2(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty);
  MaybeTerm new_mat4x3(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty);
  MaybeTerm new_mat4x4(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty);
  MaybeAbcType new_Scalar_type(AbcScalar scalar);
  MaybeAbcType new_Struct_type(const char* *fields, const FfiAbcType *types, size_t num_fields);
  MaybeAbcType new_SizedArray_type(FfiAbcType ty, uint32_t size);
  MaybeAbcType new_DynamicArray_type(FfiAbcType ty);
  char *term_to_cstr(FfiTerm term);
  MaybeSolution solve_constraints(FfiSummary summary);
  ErrorCode serialize_constraints(const char* path);
  ErrorCode mark_loop_variable(FfiTerm var, FfiTerm init, FfiTerm update_rhs, BinaryOp update_op);
  MaybeTerm new_call(FfiSummary summary, const FfiTerm *args, uint32_t num_args, FfiTerm return_dest);
  ErrorCode begin_loop(FfiTerm condition);
  ErrorCode end_loop();
  ErrorCode add_assumption(FfiTerm lhs, AssumptionOp op, FfiTerm rhs);
  ErrorCode add_constraint(FfiTerm lhs, ConstraintOp op, FfiTerm rhs, uint32_t id);
  ErrorCode begin_summary(const char* name, uint8_t num_args);
  MaybeSummary end_summary();
  MaybeTerm add_argument(const char* name, FfiAbcType ty);
  ErrorCode mark_break();
  ErrorCode mark_continue();
  ErrorCode mark_type(FfiTerm term, FfiAbcType ty);
  ErrorCode begin_predicate_block(FfiTerm predicate);
  ErrorCode end_predicate_block();
  ErrorCode mark_return_type(FfiAbcType ty);
  ErrorCode mark_return(FfiTerm retval);
  ErrorCode mark_array_length(FfiTerm array, uint8_t dim, uint32_t size);
  ErrorCode mark_range(FfiTerm term, Literal lower, Literal upper);
  FfiTerm get_empty_term();
"""