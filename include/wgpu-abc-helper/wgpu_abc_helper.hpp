// SPDX-FileCopyrightText: 2024 University of Rochester 
//
// SPDX-License-Identifier: MIT


#pragma once

/* Generated with cbindgen:0.28.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>
#include <cassert>
#pragma once
// Forward declarations

namespace abc_helper
{
    struct FfiTerm;
    struct FfiAbcType;
    struct MaybeTerm;
    struct FfiTerm;
    struct FfiAbcType;
    struct Context;
    enum class ErrorCode;
    struct MaybeContext;
    struct FfiSummary;
    enum class BinaryOp;
    enum class CmpOp;
    struct Literal;
    struct MaybeAbcType;
    struct AbcScalar;
    struct MaybeSummary;
    struct FfiSummary;
    struct MaybeSolution;
    struct ConstraintResult;
    struct ConstraintOp;
    enum class SolverResult;
    enum class AssumptionOp;
}

namespace abc_helper {

/// The maximum number of constraints that can be added per summary.
constexpr static const size_t CONSTRAINT_LIMIT = (size_t)UINT32_MAX;

/// The maximum number of summaries that can be added to a constraint helper.
constexpr static const size_t SUMMARY_LIMIT = (size_t)(UINT32_MAX - 1);

/// A constraint operation is any comparison operator OR an assignment.
enum class AssumptionOp {
  Assign,
  Lt,
  Gt,
  Leq,
  Geq,
};

enum class BinaryOp {
  Plus,
  Minus,
  Times,
  Mod,
  Div,
  BitAnd,
  BitOr,
  BitXor,
  Shl,
  Shr,
};

///A comparison operator used by ccates.
enum class CmpOp {
  Eq = 0,
  Neq,
  Lt,
  Gt,
  Leq,
  Geq,
};

enum class ErrorCode {
  Success = 0,
  /// Indicates a panic in the Rust code.
  Panic = 1,
  /// Indicates an improper value
  ValueError = 2,
  /// Indicates a poisoned lock
  ///
  /// This occurs when a thread panics while holding a lock.
  PoisonedLock = 3,
  /// Indicates a term that does not exist in the context.
  ///
  /// This means the term was either already deleted or never created.
  InvalidTerm = 4,
  /// Indicates that a type does not exist in the context.
  ///
  /// This means the type was either already deleted or never created.
  InvalidType = 5,
  /// Indicates that a summary does not exist in the context.
  ///
  /// This means the summary was either already deleted or never created.
  InvalidSummary = 6,
  /// Indicate a null pointer was passed.
  NullPointer = 7,
  /// Indicates a passed pointer was not properly aligned.
  AlignmentError = 8,
  /// Indicates a forbidden zero value passed as an arugment.
  ForbiddenZero = 9,
  /// Indicates that the library is at maximum capacity.
  CapacityExceeded = 10,
  /// Indicates that the wrong `AbcType` was passed.
  WrongType = 11,
  /// Indicates that the context does not exist in the global context map.
  InvalidContext = 12,
  /// Indicates that a file error occurred.
  FileError = 13,
  /// An error occured during serialization
  SerializationError = 14,
  /// An error indicating the operation is not supported for the method.
  UnsupportedOperation = 15,
  /// Indicates that the predicate stack is empty
  PredicateStackEmpty = 16,
  /// Indicates that there is no active summary when one is required.
  NotInSummary = 17,
  /// Indicates an attempt to declare the type of the same term multiple times.
  DuplicateType = 18,
  /// Indicates that the requested operation is not implemented
  NotImplemented = 19,
  /// Indicates an attempt to use a `break` or `continue` outside of a loop context.
  NotInLoopContext = 20,
  /// Indicates that the maximum loop depth has been exceeded.
  MaxLoopDepthExceeded = 21,
  EmptyTerm = 22,
  /// Indicates that the arguments to a method call were incorrect.
  InvalidArguments = 23,
  /// Indicates an attempt to assign the return value of a function that does not return a value.
  NoReturnValue = 24,
  /// Indicates that the loop condition is not supported.
  UnsupportedLoopCondition = 25,
  /// Indicates the type is not supported for the requested operation.
  UnsupportedType = 26,
  /// Indicates that an additional assumption on the same boundary of a term was attempted.
  DuplicateAssumption = 27,
  /// Indicates an error that went wrong during the solving process.
  SolverError = 28,
  /// Indicates the number of constraints exceeded the maximum allowed.
  ConstraintLimitExceeded = 29,
  /// Indicates the number of summaries exceeded the maximum allowed.
  SummaryLimitExceeded = 30,
};

/// The error codes that can be returned by `abc_solve_constraints` method.
enum class SolverErrorCode {
  /// Summary is invalid.
  InvalidSummary = 1,
  /// Unsupported type for an operation
  UnsupportedType = 2,
  /// Multiple assumptions for the same term.
  DuplicateAssignmentError = 3,
  InvalidOp = 4,
  /// Multiple assignments to the same term.
  /// The only term that this can occur for is `ret`.
  ///
  /// `Ret` is special, it is the only term that may be assigned to more than once.
  SsaViolation = 5,
  TypeMismatch = 6,
  Unexpected = 7,
  Unsupported = 8,
  /// Top level constraints can not be satisfied.
  DeadCode = 9,
  /// The lock on the global contexts is poisoned.
  PoisonedLock = 10,
  /// The context does not exist.
  InvalidContext = 11,
};

enum class SolverResult {
  Yes,
  Maybe,
  No,
};

/// A unary operation. Currently only supports unary minus.
enum class UnaryOp {
  Minus,
};

/// For ffi bindings, term does not contain the actual term data, but instead a handle to it.
///
/// This handle corresponds to an index in the `Terms` vector, a static global variable in this library.
/// This is because `Term` has members that are not FFI-Safe.
struct FfiTerm {
  size_t id;
  auto get_id() {
    return id;
  }
};

/// A context refers to a collection of terms, types, and summaries for a single compilation unit.
///
/// You must use different contexts for different compilation units.
/// When you are done with a context, it is important to call `abc_free_context` to free the resources.
struct Context {
  auto get_id() {
    return this->id;
  }
  
  size_t id;
public:
  MaybeTerm new_unit_pred(FfiTerm term);
  MaybeTerm new_literal_true();
  MaybeTerm new_literal_false();
  MaybeTerm new_logical_and(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_logical_or(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_comparison(CmpOp op, FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_not(FfiTerm t);
  MaybeTerm new_var(const char* s);
  MaybeTerm new_cast(FfiTerm source_term, FfiAbcType ty);
  MaybeTerm new_cmp_term(CmpOp op, FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_index_access(FfiTerm base, FfiTerm index);
  MaybeTerm new_struct_access(FfiTerm base, const char* field, FfiAbcType ty, size_t field_idx);
  MaybeTerm new_splat(FfiTerm term, uint32_t size);
  MaybeTerm new_literal(Literal lit);
  MaybeTerm new_binary_op(BinaryOp op, FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_unary_op(UnaryOp op, FfiTerm term);
  MaybeTerm new_max(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_min(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_select(FfiTerm iftrue, FfiTerm iffalse, FfiTerm predicate);
  MaybeTerm new_vec2(FfiTerm term_0, FfiTerm term_1, FfiAbcType ty);
  MaybeTerm new_vec3(FfiTerm term_0, FfiTerm term_1, FfiTerm term_2, FfiAbcType ty);
  MaybeTerm new_vec4(FfiTerm term_0, FfiTerm term_1, FfiTerm term_2, FfiTerm term_3, FfiAbcType ty);
  MaybeTerm new_array_length(FfiTerm term);
  MaybeTerm new_array_store(FfiTerm base, FfiTerm index, FfiTerm value);
  MaybeTerm new_store(FfiTerm base, const char* field, size_t field_idx, FfiTerm value);
  MaybeTerm new_struct_store(FfiTerm base, size_t field_idx, FfiTerm value);
  MaybeTerm new_abs(FfiTerm term);
  MaybeTerm new_pow(FfiTerm base, FfiTerm exponent);
  MaybeTerm new_dot(FfiTerm lhs, FfiTerm rhs);
  MaybeTerm new_mat2x2(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty);
  MaybeTerm new_mat2x3(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty);
  MaybeTerm new_mat2x4(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty);
  MaybeTerm new_mat3x2(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty);
  MaybeTerm new_mat3x3(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty);
  MaybeTerm new_mat3x4(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty);
  MaybeTerm new_mat4x2(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty);
  MaybeTerm new_mat4x3(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty);
  MaybeTerm new_mat4x4(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty);
  MaybeAbcType new_Scalar_type(AbcScalar scalar);
  MaybeAbcType new_Struct_type(const char* *fields, const FfiAbcType *types, size_t num_fields);
  MaybeAbcType new_SizedArray_type(FfiAbcType ty, uint32_t size);
  MaybeAbcType new_DynamicArray_type(FfiAbcType ty);
  char *term_to_cstr(FfiTerm term);
  MaybeSolution solve_constraints(FfiSummary summary);
  ErrorCode serialize_constraints(const char* path);
  ErrorCode mark_loop_variable(FfiTerm var, FfiTerm init, FfiTerm update_rhs, BinaryOp update_op);
  MaybeTerm new_call(FfiSummary summary, const FfiTerm *args, uint32_t num_args, FfiTerm return_dest);
  ErrorCode begin_loop(FfiTerm condition);
  ErrorCode end_loop();
  ErrorCode add_assumption(FfiTerm lhs, AssumptionOp op, FfiTerm rhs);
  ErrorCode add_constraint(FfiTerm lhs, ConstraintOp op, FfiTerm rhs, uint32_t id);
  ErrorCode begin_summary(const char* name, uint8_t num_args);
  MaybeSummary end_summary();
  MaybeTerm add_argument(const char* name, FfiAbcType ty);
  ErrorCode mark_break();
  ErrorCode mark_continue();
  ErrorCode mark_type(FfiTerm term, FfiAbcType ty);
  ErrorCode begin_predicate_block(FfiTerm predicate);
  ErrorCode end_predicate_block();
  ErrorCode mark_return_type(FfiAbcType ty);
  ErrorCode mark_return(FfiTerm retval);
  ErrorCode mark_array_length(FfiTerm array, uint8_t dim, uint32_t size);
  ErrorCode mark_range(FfiTerm term, Literal lower, Literal upper);
  FfiTerm get_empty_term();
};

struct MaybeContext {
  enum class Tag {
    Error,
    Success,
  };

  struct Error_Body {
    ErrorCode _0;
  };

  struct Success_Body {
    Context _0;
  };

  Tag tag;
  union {
    Error_Body error;
    Success_Body success;
  };

  static MaybeContext Error(const ErrorCode &_0) {
    MaybeContext result;
    ::new (&result.error._0) (ErrorCode)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const ErrorCode& AsError() const {
    assert(IsError());
    return error._0;
  }

  static MaybeContext Success(const Context &_0) {
    MaybeContext result;
    ::new (&result.success._0) (Context)(_0);
    result.tag = Tag::Success;
    return result;
  }

  bool IsSuccess() const {
    return tag == Tag::Success;
  }

  const Context& AsSuccess() const {
    assert(IsSuccess());
    return success._0;
  }
};

/// cffi abc type wrapper.
///
/// This is just a wrapper around a usize that provides a safe interface to the types that have been defined in the library.
///
/// Note that type ids that have been freed via the `abc_free_type` will be reused for types created later.
struct FfiAbcType {
  auto get_id() {
    return this->id;
  }
  size_t id;
};

/// `FfiSummary` are not created by the user. They are returned only by the library by the `endSummary()`
/// method of the helper. NOTE: The alpha version of this library's cffi module does not include the helper.
struct FfiSummary {
  size_t id;
};

/// Represents a possible term, or an error code.
///
/// There is no reason to construct this enum directly; it is meant to be returned by the FFI functions.
struct MaybeTerm {
  enum class Tag {
    Error,
    Success,
  };

  struct Error_Body {
    ErrorCode _0;
  };

  struct Success_Body {
    FfiTerm _0;
  };

  Tag tag;
  union {
    Error_Body error;
    Success_Body success;
  };

  static MaybeTerm Error(const ErrorCode &_0) {
    MaybeTerm result;
    ::new (&result.error._0) (ErrorCode)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const ErrorCode& AsError() const {
    assert(IsError());
    return error._0;
  }

  static MaybeTerm Success(const FfiTerm &_0) {
    MaybeTerm result;
    ::new (&result.success._0) (FfiTerm)(_0);
    result.tag = Tag::Success;
    return result;
  }

  bool IsSuccess() const {
    return tag == Tag::Success;
  }

  const FfiTerm& AsSuccess() const {
    assert(IsSuccess());
    return success._0;
  }
};

/// A literal, ripped directly from naga's literal, with the `bool` literal dropped
/// The bool literal turns into [`Predicate::True`] or [`Predicate::False`]
///
/// [`Predicate::True`]: crate::Predicate::True
/// [`Predicate::False`]: crate::Predicate::False
struct Literal {
  enum class Tag {
    /// May not be NaN or infinity, as defined by the wgsl spec..
    F64,
    F32,
    U32,
    I32,
    U64,
    I64,
    AbstractInt,
    AbstractFloat,
  };

  struct F64_Body {
    double _0;
  };

  struct F32_Body {
    float _0;
  };

  struct U32_Body {
    uint32_t _0;
  };

  struct I32_Body {
    int32_t _0;
  };

  struct U64_Body {
    uint64_t _0;
  };

  struct I64_Body {
    int64_t _0;
  };

  struct AbstractInt_Body {
    int64_t _0;
  };

  struct AbstractFloat_Body {
    double _0;
  };

  Tag tag;
  union {
    F64_Body f64;
    F32_Body f32;
    U32_Body u32;
    I32_Body i32;
    U64_Body u64;
    I64_Body i64;
    AbstractInt_Body abstract_int;
    AbstractFloat_Body abstract_float;
  };

  static Literal F64(const double &_0) {
    Literal result;
    ::new (&result.f64._0) (double)(_0);
    result.tag = Tag::F64;
    return result;
  }

  bool IsF64() const {
    return tag == Tag::F64;
  }

  const double& AsF64() const {
    assert(IsF64());
    return f64._0;
  }

  static Literal F32(const float &_0) {
    Literal result;
    ::new (&result.f32._0) (float)(_0);
    result.tag = Tag::F32;
    return result;
  }

  bool IsF32() const {
    return tag == Tag::F32;
  }

  const float& AsF32() const {
    assert(IsF32());
    return f32._0;
  }

  static Literal U32(const uint32_t &_0) {
    Literal result;
    ::new (&result.u32._0) (uint32_t)(_0);
    result.tag = Tag::U32;
    return result;
  }

  bool IsU32() const {
    return tag == Tag::U32;
  }

  const uint32_t& AsU32() const {
    assert(IsU32());
    return u32._0;
  }

  static Literal I32(const int32_t &_0) {
    Literal result;
    ::new (&result.i32._0) (int32_t)(_0);
    result.tag = Tag::I32;
    return result;
  }

  bool IsI32() const {
    return tag == Tag::I32;
  }

  const int32_t& AsI32() const {
    assert(IsI32());
    return i32._0;
  }

  static Literal U64(const uint64_t &_0) {
    Literal result;
    ::new (&result.u64._0) (uint64_t)(_0);
    result.tag = Tag::U64;
    return result;
  }

  bool IsU64() const {
    return tag == Tag::U64;
  }

  const uint64_t& AsU64() const {
    assert(IsU64());
    return u64._0;
  }

  static Literal I64(const int64_t &_0) {
    Literal result;
    ::new (&result.i64._0) (int64_t)(_0);
    result.tag = Tag::I64;
    return result;
  }

  bool IsI64() const {
    return tag == Tag::I64;
  }

  const int64_t& AsI64() const {
    assert(IsI64());
    return i64._0;
  }

  static Literal AbstractInt(const int64_t &_0) {
    Literal result;
    ::new (&result.abstract_int._0) (int64_t)(_0);
    result.tag = Tag::AbstractInt;
    return result;
  }

  bool IsAbstractInt() const {
    return tag == Tag::AbstractInt;
  }

  const int64_t& AsAbstractInt() const {
    assert(IsAbstractInt());
    return abstract_int._0;
  }

  static Literal AbstractFloat(const double &_0) {
    Literal result;
    ::new (&result.abstract_float._0) (double)(_0);
    result.tag = Tag::AbstractFloat;
    return result;
  }

  bool IsAbstractFloat() const {
    return tag == Tag::AbstractFloat;
  }

  const double& AsAbstractFloat() const {
    assert(IsAbstractFloat());
    return abstract_float._0;
  }
};

/// Represents a possible `AbcType`, or an error code.
struct MaybeAbcType {
  enum class Tag {
    Error,
    Success,
  };

  struct Error_Body {
    ErrorCode _0;
  };

  struct Success_Body {
    FfiAbcType _0;
  };

  Tag tag;
  union {
    Error_Body error;
    Success_Body success;
  };

  static MaybeAbcType Error(const ErrorCode &_0) {
    MaybeAbcType result;
    ::new (&result.error._0) (ErrorCode)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const ErrorCode& AsError() const {
    assert(IsError());
    return error._0;
  }

  static MaybeAbcType Success(const FfiAbcType &_0) {
    MaybeAbcType result;
    ::new (&result.success._0) (FfiAbcType)(_0);
    result.tag = Tag::Success;
    return result;
  }

  bool IsSuccess() const {
    return tag == Tag::Success;
  }

  const FfiAbcType& AsSuccess() const {
    assert(IsSuccess());
    return success._0;
  }
};

/// Represents a scalar type. These are builtin types that have assumed
/// bounds on them. E.g., an i32 is assumed to have bounds -2^31 to 2^31 - 1.
///
/// Note that for Sint, Uint, and Float, the width is in **bytes**.
struct AbcScalar {
  enum class Tag {
    /// Signed integer type. The width is in bytes.
    Sint,
    /// Unsigned integer type. The width is in bytes.
    Uint,
    /// IEEE-754 Floating point type.
    Float,
    /// Boolean type.
    Bool,
    /// Abstract integer type. That is, an integer type with unknown bounds.
    AbstractInt,
    /// Abstract floating point type. That is, a floating point type with unknown bounds.
    AbstractFloat,
  };

  struct Sint_Body {
    uint8_t _0;
  };

  struct Uint_Body {
    uint8_t _0;
  };

  struct Float_Body {
    uint8_t _0;
  };

  Tag tag;
  union {
    Sint_Body sint;
    Uint_Body uint;
    Float_Body float_;
  };

  static AbcScalar Sint(const uint8_t &_0) {
    AbcScalar result;
    ::new (&result.sint._0) (uint8_t)(_0);
    result.tag = Tag::Sint;
    return result;
  }

  bool IsSint() const {
    return tag == Tag::Sint;
  }

  const uint8_t& AsSint() const {
    assert(IsSint());
    return sint._0;
  }

  static AbcScalar Uint(const uint8_t &_0) {
    AbcScalar result;
    ::new (&result.uint._0) (uint8_t)(_0);
    result.tag = Tag::Uint;
    return result;
  }

  bool IsUint() const {
    return tag == Tag::Uint;
  }

  const uint8_t& AsUint() const {
    assert(IsUint());
    return uint._0;
  }

  static AbcScalar Float(const uint8_t &_0) {
    AbcScalar result;
    ::new (&result.float_._0) (uint8_t)(_0);
    result.tag = Tag::Float;
    return result;
  }

  bool IsFloat() const {
    return tag == Tag::Float;
  }

  const uint8_t& AsFloat() const {
    assert(IsFloat());
    return float_._0;
  }

  static AbcScalar Bool() {
    AbcScalar result;
    result.tag = Tag::Bool;
    return result;
  }

  bool IsBool() const {
    return tag == Tag::Bool;
  }

  static AbcScalar AbstractInt() {
    AbcScalar result;
    result.tag = Tag::AbstractInt;
    return result;
  }

  bool IsAbstractInt() const {
    return tag == Tag::AbstractInt;
  }

  static AbcScalar AbstractFloat() {
    AbcScalar result;
    result.tag = Tag::AbstractFloat;
    return result;
  }

  bool IsAbstractFloat() const {
    return tag == Tag::AbstractFloat;
  }
};

/// The result of a constraint.
struct ConstraintResult {
  uint32_t _0;
  SolverResult _1;
};

struct ConstraintSolution {
  /// The size of the results array.
  size_t len;
  const ConstraintResult *results;
};

/// The solution to the constraints.
struct MaybeSolution {
  enum class Tag {
    Success,
    Error,
  };

  struct Success_Body {
    ConstraintSolution _0;
  };

  struct Error_Body {
    SolverErrorCode _0;
  };

  Tag tag;
  union {
    Success_Body success;
    Error_Body error;
  };

  static MaybeSolution Success(const ConstraintSolution &_0) {
    MaybeSolution result;
    ::new (&result.success._0) (ConstraintSolution)(_0);
    result.tag = Tag::Success;
    return result;
  }

  bool IsSuccess() const {
    return tag == Tag::Success;
  }

  const ConstraintSolution& AsSuccess() const {
    assert(IsSuccess());
    return success._0;
  }

  static MaybeSolution Error(const SolverErrorCode &_0) {
    MaybeSolution result;
    ::new (&result.error._0) (SolverErrorCode)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const SolverErrorCode& AsError() const {
    assert(IsError());
    return error._0;
  }
};

/// Represents a possible summary, or an error code.
struct MaybeSummary {
  enum class Tag {
    Error,
    Success,
  };

  struct Error_Body {
    ErrorCode _0;
  };

  struct Success_Body {
    FfiSummary _0;
  };

  Tag tag;
  union {
    Error_Body error;
    Success_Body success;
  };

  static MaybeSummary Error(const ErrorCode &_0) {
    MaybeSummary result;
    ::new (&result.error._0) (ErrorCode)(_0);
    result.tag = Tag::Error;
    return result;
  }

  bool IsError() const {
    return tag == Tag::Error;
  }

  const ErrorCode& AsError() const {
    assert(IsError());
    return error._0;
  }

  static MaybeSummary Success(const FfiSummary &_0) {
    MaybeSummary result;
    ::new (&result.success._0) (FfiSummary)(_0);
    result.tag = Tag::Success;
    return result;
  }

  bool IsSuccess() const {
    return tag == Tag::Success;
  }

  const FfiSummary& AsSuccess() const {
    assert(IsSuccess());
    return success._0;
  }
};

/// A constraint operation is any comparison operator OR an assignment.
struct ConstraintOp {
  enum class Tag {
    Unary,
    Cmp,
  };

  struct Cmp_Body {
    CmpOp _0;
  };

  Tag tag;
  union {
    Cmp_Body cmp;
  };

  static ConstraintOp Unary() {
    ConstraintOp result;
    result.tag = Tag::Unary;
    return result;
  }

  bool IsUnary() const {
    return tag == Tag::Unary;
  }

  static ConstraintOp Cmp(const CmpOp &_0) {
    ConstraintOp result;
    ::new (&result.cmp._0) (CmpOp)(_0);
    result.tag = Tag::Cmp;
    return result;
  }

  bool IsCmp() const {
    return tag == Tag::Cmp;
  }

  const CmpOp& AsCmp() const {
    assert(IsCmp());
    return cmp._0;
  }
};









extern "C" {

/// Get the `empty` term.
///
/// The empty term is used to represent the absence of a term.
/// It is used in several methods that require a term to indicate that the term is unimportant.
///
/// For example, it must be passed when invoking a method that does not return a value.
///
/// Attempting to delete the empty term will do nothing, but will not result in an error.
/// That is, the empty term is *always* valid, in any context.
FfiTerm abc_get_empty_term();

MaybeContext abc_new_context();

/// Free the context from the global context map.
///
/// Freeing a context will deallocate all of the memory that has been
/// associated with it and allow its id to be reused. Attempting to use
/// the `Context` after it has been freed may modify a different context
/// if its id has been reused.
ErrorCode abc_free_context(Context context);

/// Free the term from the term map.
///
/// Freeing a term will remove it from the global terms map and allow its id
/// to be reused. This will *not* break any terms that refer to this term.
/// For example, if `x` is the term being freed, then a term for
/// the expression `x + 1` will continue to work as expected.
///
/// # Returns
/// `ErrorCode::Success` if the term was successfully removed.
/// `ErrorCode::PoisonedLock` if the lock on the global terms map is poisoned.
/// `ErrorCode::InvalidContext` if the provided context does not exist in the global context map.
ErrorCode abc_free_term(Context self, FfiTerm term);

/// Free the term from the term map.
///
/// Freeing a type will remove it from the type map and allow its id to be
/// reused. This will *not* break any terms or summaries that have used this
/// type.
///
/// # Returns
/// `ErrorCode::Success` if the term was successfully removed.
/// `ErrorCode::PoisonedLock` if the lock on the global context is poisoned.
ErrorCode abc_free_type(Context self, FfiAbcType ty);

/// Remove the summary from the library's collection of summaries. This
/// can be used to free the summary when it is no longer needed.
///
/// Summaries are not created by the user. They are returned only by the library by the `endSummary()`
/// method of the helper. NOTE: The alpha version of this library's cffi module does not include the helper.
///
/// However,
///
/// **After calling this method, the summary must not be used.**
///
/// # Returns
/// `ErrorCode::Success` if the summary was successfully removed, otherwise an error described below.
///
/// # Errors
/// `ErrorCode::SummaryNotFound` is returned if the summary was not found in the library's collection.
/// `ErrorCode::PoisonedLock` is returned if the lock on the contexts map is poisoned.
/// `ErrorCode::InvalidContext` is returned if the provided context does not exist in the global context map.
///
/// This can be thought of as the destructor for the summary, and should be called
/// as long as the summary is no longer needed.
///
/// That is, calling `delete` will just remove the summary from the library's collection.
ErrorCode abc_free_summary(Context self,
                           FfiSummary summary);

/// Create a new unit predicate. Must only be used on the `Variable` variant of `Term` or the following `Expression` variants
/// - A `Select` where the `iftrue` and `iffalse` are booleans.
/// - A `FieldAccess` where the accessed field is a `bool`
/// - An `AccessIndex` on an array of `bool`s
/// - A `cast` to a boolean type.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// - [`ErrorCode::PoisonedLock`] if the lock on the global context is poisoned.
/// - [`ErrorCode::InvalidTerm`] if the term does not exist in the library's collection.
/// - [`ErrorCode::InvalidContext`] if the provided context does not exist in the library's collection.
MaybeTerm abc_new_unit_pred(Context self,
                            FfiTerm term);

/// Create a Term holding the `true` predicate
MaybeTerm abc_new_literal_true(Context self);

/// Create a Term holding the `false` predicate
MaybeTerm abc_new_literal_false(Context self);

/// Constructs the Predicate term `lhs && rhs`.
///
/// # Arguments
/// - `lhs`: The left-hand side of the logical and. Must be a predicate term.
/// - `rhs`: The right-hand side of the logical and. Must be a predicate term.
///
/// Use [`abc_new_unit_pred`] to convert variables and expression terms to predicates that can be used in this function.
///
/// # Errors
/// - [`ErrorCode::PoisonedLock`] if the lock on the global context is poisoned.
/// - [`ErrorCode::InvalidTerm`] if either `lhs` or `rhs` do not exist in the library's collection.
/// - [`ErrorCode::InvalidContext`] if the provided context does not exist in the library's collection.
MaybeTerm abc_new_logical_and(Context self,
                              FfiTerm lhs,
                              FfiTerm rhs);

/// Constructs the Predicate Term `lhs || rhs`.
///
/// # Arguments
/// - `lhs`: The left-hand side of the logical or. Must be a predicate term.
/// - `rhs`: The right-hand side of the logical or. Must be a predicate term.
///
/// Use [`abc_new_unit_pred`] to convert variables and expression terms to predicates that can be used in this function.
///
/// # Errors
/// - [`ErrorCode::PoisonedLock`] if the lock on the global context is poisoned.
/// - [`ErrorCode::InvalidTerm`] if either `lhs` or `rhs` do not exist in the library's collection.
/// - [`ErrorCode::InvalidContext`] if the provided context does not exist in the library's collection.
MaybeTerm abc_new_logical_or(Context self,
                             FfiTerm lhs,
                             FfiTerm rhs);

/// Constructs the predicate term `lhs op rhs`
///
/// # Arguments
/// - `op`: The comparison operator to use.
/// - `lhs`: The left-hand side of the comparison. Must be a predicate term.
/// - `rhs`: The right-hand side of the comparison.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// - [`ErrorCode::InvalidTerm`] is returned if either `lhs` or `rhs` do not exist in the library's collection.
/// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
/// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
MaybeTerm abc_new_comparison(Context self,
                             CmpOp op,
                             FfiTerm lhs,
                             FfiTerm rhs);

/// Constructs the predicate term `!t`
///
/// If `t` is already a [`Predicate::Not`], then it removes the `!`
///
/// # Errors
/// - [`ErrorCode::InvalidTerm`] is returned if `t` does not exist in the library's collection.
/// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
/// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
///
/// [`Predicate::Not`]: crate::Predicate::Not
MaybeTerm abc_new_not(Context self,
                      FfiTerm t);

/// Create a new variable term, with the provided name.
///
/// It is important to remember that terms must have unique names! All terms
/// are required to use SSA naming within a context. This includes terms defined within their own summaries.
///
/// # Errors
/// - [`ErrorCode::NullPointer`] is returned if the string passed is null.
/// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
/// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
MaybeTerm abc_new_var(Context self,
                      const char* s);

/// Mark a variable term as [uniform](https://www.w3.org/TR/WGSL/#address-spaces-uniform).
///
/// Arguments:
/// - `var`: The variable term to mark as uniform. Must be a term previously declared as a variable via `abc_new_var`.
///
/// Constraints that would be able to be eliminated in the case that
/// it knew the value of every uniform variable, and the sizes of all runtime-sized arrays,
/// will have their "No" answers replaced with "Maybe" answers.
///
/// # Errors
/// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
/// - [`ErrorCode::InvalidTerm`] is returned if the provided term does not exist in the context.
/// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
/// - [`ErrorCode::WrongType`] is returned if the term passed is not a variable term.
ErrorCode abc_mark_uniform(Context self,
                           FfiTerm var);

/// Create a new `cast` expression. This corresponds to the `as` operator in WGSL.
///
/// `source_term` is the term to cast, and `ty` is the type to cast it to.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if the term was not valid.
///
/// # Errors
/// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global Terms or Types is poisoned.
/// - [`ErrorCode::InvalidType`] is returned if `ty` is not found in the context.
/// - [`ErrorCode::InvalidTerm`] is returned if `source_term` is not found in the context.
/// - [`ErrorCode::WrongType`] is returned if the type passed is not a scalar type.
MaybeTerm abc_new_cast(Context self,
                       FfiTerm source_term,
                       FfiAbcType ty);

/// Create a new comparison term, e.g. `x > y`.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid
///
/// # Errors
/// - [`ErrorCode::InvalidTerm`] is returned if either `lhs` or `rhs` do not exist in the library's collection.
MaybeTerm abc_new_cmp_term(Context self,
                           CmpOp op,
                           FfiTerm lhs,
                           FfiTerm rhs);

/// Create a new index access term, e.g. `x[y]`.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `base` or `index` do not exist in the context.
MaybeTerm abc_new_index_access(Context self,
                               FfiTerm base,
                               FfiTerm index);

/// Create a new struct access term, e.g. `x.y`.
///
/// # Arguments
/// - `base`: The base term whose field is being accessed
/// - `field`: The name of the field being accessed.
/// - `ty`: The type of the struct being accessed. This is needed for term validation.
/// - `field_idx`: The index of the field in the structure being accessed.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term or type could not be found.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if `base` does not exist in the context.
/// [`ErrorCode::PoisonedLock`] is returned if the lock on the global Terms or Types container is poisoned.
MaybeTerm abc_new_struct_access(Context self,
                                FfiTerm base,
                                const char* field,
                                FfiAbcType ty,
                                size_t field_idx);

/// Create a new splat term, e.g. `vec3(x)`.
///
/// A `splat` is just shorthand for a vector of size `size` where each element is `term`.
///
/// # Arguments
/// - `term`: The term to splat.
/// - `size`: The number of elements in the vector. Must be between 2 and 4  (inclusive).
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if `term` does not exist in the library's collection.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::ValueError` if `size` is not between 2 and 4.
MaybeTerm abc_new_splat(Context self,
                        FfiTerm term,
                        uint32_t size);

/// Create a new literal term.
///
/// # Returns
/// A `MaybeTerm` which is either a new `Literal` variant of `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_literal(Context self,
                          Literal lit);

/// Create a binary operation term, e.g. `x + y`.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the library's collection.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_binary_op(Context self,
                            BinaryOp op,
                            FfiTerm lhs,
                            FfiTerm rhs);

/// Create a new unary operation term, e.g. `-x`.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_unary_op(Context self,
                           UnaryOp op,
                           FfiTerm term);

/// Create a new term corresponding to wgsl's [`max`](https://www.w3.org/TR/WGSL/#max-float-builtin) bulitin.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_max(Context self,
                      FfiTerm lhs,
                      FfiTerm rhs);

/// Create a new term corresponding to wgsl's [`min`](https://www.w3.org/TR/WGSL/#min-float-builtin) builtin.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_min(Context self,
                      FfiTerm lhs,
                      FfiTerm rhs);

/// Create a new term akin to wgsl's [`select`](https://www.w3.org/TR/WGSL/#select-builtin) bulitin.
///
/// ### Note: In this method, the condition is the first argument, while it is the last argument in the WGSL builtin.
///
///
/// # Arguments
/// - `iftrue`: The expression this term evaluates to if `predicate` is true
/// - `iffalse`: The expression this term evaluates to if `predicate` is false
/// - `Predicate`: The term that determines the resolution of `iftrue` or `iffalse`.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `lhs`, `m`, or `rhs` do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_select(Context self,
                         FfiTerm iftrue,
                         FfiTerm iffalse,
                         FfiTerm predicate);

/// Create a new term corresponding to wgsl's `vec2` type. This should not be confused with array types.
///
/// # Arguments
/// - `term_0`: The first term in the vector
/// - `term_1`: The second term in the vector
/// - `ty`: The type of the terms in the vector
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the terms do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_vec2(Context self,
                       FfiTerm term_0,
                       FfiTerm term_1,
                       FfiAbcType ty);

/// Create a new term corresponding to wgsl's `vec3` type. This should not be confused with array types.
///
/// # Arguments
/// - `term_0`: The first term in the vector
/// - `term_1`: The second term in the vector
/// - `term_3`: The third term in the vector
/// - `ty`: The type of the terms in the vector
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the terms do not exist in the context.
/// `ErrorCode::InvalidType` if `ty` does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_vec3(Context self,
                       FfiTerm term_0,
                       FfiTerm term_1,
                       FfiTerm term_2,
                       FfiAbcType ty);

/// Create a new term corresponding to wgsl's `vec4` type. This should not be confused with array types.
///
/// # Arguments
/// - `term_0`: The first term in the vector
/// - `term_1`: The second term in the vector
/// - `term_2`: The third term in the vector
/// - `term_3`: The fourth term in the vector
/// - `ty`: The type of the terms in the vector
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the terms do not exist in the context.
/// `ErrorCode::InvalidType` if `ty` does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_vec4(Context self,
                       FfiTerm term_0,
                       FfiTerm term_1,
                       FfiTerm term_2,
                       FfiTerm term_3,
                       FfiAbcType ty);

/// Create a new `array_length` term corresponding to the `arrayLength` operator in WGSL.
/// Note that `wgsl` only defines this method for dynamically sized arrays. This method is
/// not valid for fixed-sized arrays, matrices, or vectors.
///
/// ### Notes
/// Do not use this term to add a constraint on the length of an array. Instead, invoke the solver's `mark_length` method.
/// This method is only meant to be used in the case that `arrayLength` is spelled in wgsl source.
///
/// # Arguments
/// - `term`: The array term that this expression is being applied to.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_array_length(Context self,
                               FfiTerm term);

/// Create a new `store` term.
///
/// There is no explicit wgsl method that this corresponds to. However, it must be used when writing to array in
/// order to respect SSA requirements. This method creates a new term where each array element is the same as the
/// original array, except for the element at `index`, which is `value`.
///
/// # Arguments
/// - `term`: The array term that is being written to.
/// - `index`: The index of the array that is being written to.
/// - `value`: The value that is being written to the array.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_store(Context self,
                        FfiTerm term,
                        FfiTerm index,
                        FfiTerm value);

/// Create a new struct store term.
///
/// There is no explicit wgsl method that this corresponds to. However, it must be used when writing to a struct in
/// order to respect SSA requirements. This method creates a new term where each field is the same as the
/// original struct, except for the field at `field_idx`, which is `value`.
///
/// # Arguments
/// - `term`: The struct term that is being written to.
/// - `field_idx`: The index of the field that is being written to.
/// - `value`: The value that is being written to the struct.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_struct_store(Context self,
                               FfiTerm term,
                               size_t field_idx,
                               FfiTerm value);

/// Create a new absolute value term corresponding to the [`abs`](https://www.w3.org/TR/WGSL/#abs-float-builtin) operator in WGSL.
///
/// # Arguments
/// - `term`: The term that is being passed to the `abs` operator.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_abs(Context self,
                      FfiTerm term);

/// Create a new `pow` term corresponding to the [`pow`](https://www.w3.org/TR/WGSL/#pow-builtin) builtin in WGSL.
///
/// # Arguments
/// - `base`: The base of the power operation.
/// - `exponent`: The exponent of the power operation.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `base` or `exponent` do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_pow(Context self,
                      FfiTerm base,
                      FfiTerm exponent);

/// Create a new term corresponding to wgsl's [`dot`](https://www.w3.org/TR/WGSL/#dot-builtin) builtin.
///
/// # Arguments
/// - `lhs`: The left-hand side of the dot product.
/// - `rhs`: The right-hand side of the dot product.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
MaybeTerm abc_new_dot(Context self,
                      FfiTerm lhs,
                      FfiTerm rhs);

/// Create a new `mat2x2` term
///
/// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec2`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec2`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat2x2(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiAbcType ty);

/// Create a new `mat2x3` term
///
/// The components of the matrix must correspond to `vec3` terms, which can be created via the `new_vec3`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec3`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat2x3(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiAbcType ty);

/// Create a new `mat2x4` term
///
/// The components of the matrix must correspond to `vec4` terms, which can be created via the `new_vec4`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat2x4(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiAbcType ty);

/// Create a new `mat3x2` term
///
/// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec2`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec2`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `row_2`: The third row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat3x2(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiTerm row_2,
                         FfiAbcType ty);

/// Create a new `mat3x3` term
///
/// The components of the matrix must correspond to `vec3` terms, which can be created via the `new_vec3`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `row_2`: The third row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat3x3(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiTerm row_2,
                         FfiAbcType ty);

/// Create a new `mat3x4` term
///
/// The components of the matrix must correspond to `vec4` terms, which can be created via the `new_vec4`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `row_2`: The third row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat3x4(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiTerm row_2,
                         FfiAbcType ty);

/// Create a new `mat4x2` term
///
/// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec3`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec3`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `row_2`: The third row of the matrix.
/// - `row_3`: The fourth row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat4x2(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiTerm row_2,
                         FfiTerm row_3,
                         FfiAbcType ty);

/// Create a new `mat4x3` term
///
/// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec3`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec3`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `row_2`: The third row of the matrix.
/// - `row_3`: The fourth row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat4x3(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiTerm row_2,
                         FfiTerm row_3,
                         FfiAbcType ty);

/// Create a new `mat4x4` term
///
/// The components of the matrix must correspond to `vec4` terms, which can be created via the `new_vec4`
/// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
///
/// # Arguments
/// - `row_0`: The first row of the matrix.
/// - `row_1`: The second row of the matrix.
/// - `row_2`: The third row of the matrix.
/// - `row_3`: The fourth row of the matrix.
/// - `ty`: The type of the terms in the matrix. This must be a scalar.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
/// `ErrorCode::InvalidType` if the type does not exist in the context.
/// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// `ErrorCode::WrongType` if the type passed is not a scalar type.
MaybeTerm abc_new_mat4x4(Context self,
                         FfiTerm row_0,
                         FfiTerm row_1,
                         FfiTerm row_2,
                         FfiTerm row_3,
                         FfiAbcType ty);

/// Get the string representation of the term.
///
/// If the term is invalid, `<NotFound>` is returned.
/// Note: The returned string must be freed by calling `abc_free_string` or this will lead to a memory leak.
char *abc_term_to_cstr(Context self,
                       FfiTerm term);

/// Free a string that was allocated by the library.
///
/// # Safety
/// The caller must ensure that the pointer passed is a valid pointer to a string allocated by the library.
/// Currently, these are only strings that are returned by [`abc_term_to_cstr`].
void abc_free_string(char *s);

/// Create a new `scalar` type from an `AbcScalar`.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
MaybeAbcType abc_new_Scalar_type(Context self, AbcScalar scalar);

/// Create a new struct type. Takes a list of fields, each of which is a tuple of a string and an `AbcType`.
///
/// `num_fields` specifies how many fields are passed. It MUST be at least as long as the number of fields and types
/// passed.
///
/// # Safety
/// The caller must ensure that the `fields` and `types` pointers are not null, and that the `len`
/// parameter is at least as long as the number of elements and fields.
///
/// This method does check that the pointers are properly aligned and not null.
/// However, the caller must ensure that the pointers hold at least `len` elements.
/// Otherwise, behavior is undefined.
///
/// # Errors
/// - `ErrorCode::NullPointer` if either `fields` or `types` is null.
/// - `ErrorCode::AlignmentError` if the pointers are not properly aligned.
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidType` if any of the types passed do not exist the context.
MaybeAbcType abc_new_Struct_type(Context self,
                                 const char* *fields,
                                 const FfiAbcType *types,
                                 size_t num_fields);

/// Declare a new `SizedArray` type. `size` is the number of elements in the array. This cannot be 0.
///
/// # Errors
/// - `ErrorCode::InvalidType` is returned if the type passed does not exist in the context.
/// - `ErrorCode::PoisonedLock` is returned if the lock on the global contexts is poisoned.
/// - `ErrorCode::ForbiddenZero` is returned if the size is 0.
MaybeAbcType abc_new_SizedArray_type(Context self,
                                     FfiAbcType ty,
                                     uint32_t size);

/// Declare a new Dynamic Array type of the elements of the type passed.
///
/// # Errors
/// - `ErrorCode::InvalidType` is returned if the type passed does not exist in the context.
/// - `ErrorCode::PoisonedLock` is returned if the lock on the global contexts is poisoned.
/// - `ErrorCode::ForbiddenZero` is returned if the size is 0.
MaybeAbcType abc_new_DynamicArray_type(Context self, FfiAbcType ty);

/// Free the solution vector. After calling this method, the solution is no longer valid
/// This must be called to avoid a memory leak.
void abc_free_solution(ConstraintSolution solution);

/// Solve the constraints for the provided summary.
///
/// Note that the returned solution *must be freed* by calling `abc_free_solution` otherwise
/// a memory leak will occur.
///
/// This will return an `FfiSolution` which contains the results.
/// The results are in the form (id, result). `id` corresponds to the
/// id of the constraint that was provided when the constraint was added.
/// the `result` corresponds to the result of the constraint. It is `Yes`
/// if the constraint is always satisfied. In this case, the bounds check
/// can be removed. `No` means that the constraint could not
/// be proven to always be satisfied. In this case, the bounds check
/// must be kept. `Maybe` means that the constraint can be tested for
/// satisfiability if the system is provided with concrete values for
/// all uniform variables and array lengths.
///
/// In this current implementation, there is not a distinction
/// between checks that are always violated and checks that may be violated.
///
///
/// # Errors
/// - `SolverErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `SolverErrorCode::InvalidContext` if the context does not exist.
/// - `SolverErrorCode::InvalidSummary` if the summary does not exist in the context.
/// - Many other errors may be returned that occur during the solving process.
MaybeSolution abc_solve_constraints(Context self, FfiSummary summary);

/// Serializes the constraint system to json.
/// The input should be a file path where the serialized json will be written.
ErrorCode abc_serialize_constraints(Context self, const char* path);

/// Mark a variable as a loop variable.
///
/// A loop variable is any variable that is updated within a loop. Supported operations
/// are limited to binary operations. For best results, the increment / decrement term must be
/// a constnat.
///
/// # Arguments
/// - `var`: The induction variable.
/// - `init`: The expression the induction variable is initialized to.
/// - `update_rhs`: The expression that the term is incremented / decremented by
/// - `update_op`: The operation that is used to update the term.
///
/// Note that `inc_term` and `inc_op` are parts of the expression with the induction term.
/// That is, only expressions of the form `a = a op b` are allowed, where `a` is the induction variable.
/// This method should come **before** the `begin_loop` call.
///
/// # Errors
/// - `ErrorCode::InvalidTerm` if any of the terms passed are invalid.
/// - `ErrorCode::UnsupportedOperation` if the operation is not supported for loops.
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
ErrorCode abc_mark_loop_variable(Context self,
                                 FfiTerm var,
                                 FfiTerm init,
                                 FfiTerm update_rhs,
                                 BinaryOp update_op);

/// Add the constraints of the summary by invoking the function call with the proper arguments.
///
///
/// # Arguments
/// - `summary`: The summary for the function being invoked
/// - `args`: An array containing the arguments that are passed to the function.
/// - `num_args`: The size of the `args` array.
/// - `return_dest`: A fresh variable term that will hold the return value. If the return value is not used,
///   then this must be the `Empty` term.
///
/// This will add the constraints of the summary to the constraint system, with
/// the arguments substituted with `args`, and the return value substituted with `return_dest`.
///
/// # Safety
/// The caller must ensure that `args` holds at least `num_args` elements.
///
/// # Errors
/// - `ErrorCode::NullPointer` if `args` is null and `num_args` is not 0.
/// - `ErrorCode::AlignmentError` if `args` is not properly aligned.
/// - `ErrorCode::InvalidTerm` if any of the terms passed do not exist in the context.
/// - `ErrorCode::InvalidSummary` if the summary does not exist in the context.
/// - `ErrorCode::InvalidContext` if the context does not exist.
MaybeTerm abc_new_call(Context self,
                       FfiSummary summary,
                       const FfiTerm *args,
                       uint32_t num_args,
                       FfiTerm return_dest);

/// Begins a loop context.
///
/// A loop context is akin to a predicate context. It allows for the convenience methods for `break` and `continue`
/// to be properly handled. Additionally, all updates to variables within are marked as range constraints.
///
/// The `condition` should correspond to a boolean term where one of the operands has been marked as a loop variable.
///
/// # Errors
/// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
/// - `ErrorCode::UnsupportedLoopCondition` if the condition is not a `Predicate` or `Var` term.
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
ErrorCode abc_begin_loop(Context self,
                         FfiTerm condition);

/// End a loop context.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::NotInLoopcontext` if there has been no matching call to `begin_loop`.
ErrorCode abc_end_loop(Context self);

/// Mark an assumption.
///
/// Assumptions are invariants that must hold at all times.
/// At solving time, these differ from constraints in that they are not inverted
/// to test for satisfiability.
///
/// # Arguments
/// - `lhs`: The left hand side of the assumption.
/// - `op`: The operation that is used to compare the terms.
/// - `rhs`: The right hand side of the assumption.
///
/// There can only be one assumption per direction for each term. That is,
/// each term may *either* have one equality assumption (:=) *or* one
///  inequality assumption per direction (one less / less equal, one
/// greater / greater equal). Violating this will result in a
/// `DuplicateAssumption` error.
///
/// # Errors
/// - `ErrorCode::InvalidTerm` if any term does not exist in the context.
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::DuplicateAssumption` if `lhs` has already had an assumption on the specified boundary.
ErrorCode abc_add_assumption(Context self,
                             FfiTerm lhs,
                             AssumptionOp op,
                             FfiTerm rhs);

/// Begin a summary block.
///
/// A summary block corresponds to a function definition. All constraints
/// that are added within the summary block are considered to be constraints
/// of the function.
///
/// A summary block must be ended with a call to `end_summary`, which will
/// provide the `FfiSummary` that can be used to refer to it.
///
/// # Arguments
/// - `name`: The name of the function.
/// - `num_args`: The number of arguments the function takes.
///
/// # Errors
/// - `ErrorCode::NullPointer` if `name` is null.
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::SummaryLimitExceeded` if the number of summaries exceeds the limit.
ErrorCode abc_begin_summary(Context self, const char* name, uint8_t num_args);

/// End a summary block.
///
/// This will return the `FfiSummary` that can be used to refer to the summary.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::NotInSummary` if there has been no matching call to `begin_summary`.
MaybeSummary abc_end_summary(Context self);

/// Add an argument to the active summary.
///
/// The `begin_summary` method must be called before this method.
///
/// # Arguments
/// - `name`: The name of the argument.
/// - `ty`: The type of the argument.
///
/// # Returns
/// A `MaybeTerm` which is either an `FfiTerm` if the argument was successfully created, or an `ErrorCode` if a provided term was invalid.
///
/// # Errors
/// - `ErrorCode::NullPointer` if `name` is null.
/// - `ErrorCode::InvalidType` if the type does not exist in the context.
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::NotInSummary` if there has been no matching call to `begin_summary`.
MaybeTerm abc_add_argument(Context self,
                           const char* name,
                           FfiAbcType ty);

/// Mark a break statement. (Currently unimplemented)
///
/// # Errors
/// `ConstraintError::NotImplemented`
ErrorCode abc_mark_break(Context self);

/// Mark a continue statement. (Currently unimplemented)
///
/// # Errors
/// `ConstraintError::NotImplemented`
ErrorCode abc_mark_continue(Context self);

/// Mark the type of the provided term.
///
/// # Errors
/// [`DuplicateType`] if the type of the term has already been marked.
///
/// [`DuplicateType`]: crate::ConstraintError::DuplicateType
ErrorCode abc_mark_type(Context self, FfiTerm term, FfiAbcType ty);

/// Begin a predicate block. This indicates to the solver
/// that all expressions that follow can be filtered by the predicate.
/// Any constraint that falls within a predicate becomes a soft constraint
///
/// In other words, it would be as if all constraints were of the form
/// ``p -> c``
/// Nested predicate blocks end up composing the predicates. E.g.,
/// ``begin_predicate_block(p1)`` followed by ``begin_predicate_block(p2)``
/// would mark all constraints as ``p1 && p2 -> c``
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
/// - `ErrorCode::InvalidContext` if the context does not exist.
ErrorCode abc_begin_predicate_block(Context self, FfiTerm condition);

/// End the active predicate block.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::PredicateStackEmpty` if there is no active predicate block.
ErrorCode abc_end_predicate_block(Context self);

/// Add a constraint to the system that narrows the domain of `term`.
///
/// Any active predicates are automatically applied.
///
/// There can only be one constraint per boundary side for each term. That is,
/// each term may *either* have one equality constraint (:=) *or* one
/// inequality constraint per side (one less / less equal, one
/// greater / greater equal). Violating this will result in a
/// `DuplicateConstraint` error.
///
/// # Arguments
/// - `lhs`: The left hand side of the constraint.
/// - `op`: The operation of the constraint.
/// - `rhs`: The right hand side of the constraint.
/// - `id`: The identifier that the constraint system will use to refer to
///   the constraint. Results will reference this id.
///
///
/// # Errors
/// - `TypeMismatch` if the type of `term` is different from the type of
///   `rhs` and `op` is `ConstraintOp::Assign`
/// - `MaxConstraintCountExceeded` if the maximum number of constraints has
///   been exceeded.
ErrorCode abc_add_constraint(Context self, FfiTerm lhs, ConstraintOp op, FfiTerm rhs, uint32_t id);

/// Mark a return statement.
///
/// # Arguments
/// - `retval`: The term that corresponds to the return value. If no value
///   is returned, this *must* be the `Empty` term.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
/// - `ErrorCode::InvalidContext` if the context does not exist.
ErrorCode abc_mark_return(Context self, FfiTerm retval);

/// Mark the length of an array's dimension. Only valid for dynamically
/// sized arrays.
///
///
/// It is *strongly* preferred to use the type system to mark the variable as
/// a `SizedArray` type.
/// This should *only* be used for dynamic arrays whose size is determined later.
///
/// # Arguments
/// - `term`: The array term to mark the dimension of
/// - `dim`: The term that corresponds to the 0-based dimension of the array.
/// - `size`: The size of the array.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
/// - `ErrorCode::InvalidContext` if the context does not exist.
ErrorCode abc_mark_array_length(Context self, FfiTerm term, uint8_t dim, uint64_t size);

/// Mark the range of a runtime constant. Sugar for a pair of assumptions
/// (var >= min) and (var <= max).
///
/// The `lower` and `upper` terms must be literals of the same type.
///
/// ## Notes
/// - The current predicate block is ignored, though the constraints *are*
///   added to the active summary (or global if no summary is active)
/// - This is not meant to be used for loop variables.
///   Use `mark_loop_variable` for that.
///
/// # Arguments
/// - `term`: The term to mark the range of.
/// - `lower`: The lower bound of the range.
/// - `upper`: The upper bound of the range.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::WrongType` if the two literals are not the same variant.
ErrorCode abc_mark_range(Context self, FfiTerm term, Literal lower, Literal upper);

/// Mark the return type for the active summary.
///
/// It is not necessary to call this method for functions that do not return
/// a value.
///
/// # Errors
/// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
/// - `ErrorCode::InvalidContext` if the context does not exist.
/// - `ErrorCode::InvalidSummary` if there is no active summary
/// - `ErrorCode::DuplicateType` if the return type has already been marked for the summary
ErrorCode abc_mark_return_type(Context self, FfiAbcType ty);

}  // extern "C"

}  // namespace abc_helper

/*
This file is used only for reference and synatx checking.

It adds each of the `abc_` methods that take `Context` as their first parameter, and just calls the abc version.

This makes it slightly more ergonomic to deal with contexts, as it enables the familiar
`ctx.method()` syntax, rather than `abc_method(ctx, ...)`.

This file is meant to be copy/pasted and inserted into the "trailer" field of `cbindgen.toml` so
that it is inserted into the generated header file.
*/
namespace abc_helper
{
    /// Create a new unit predicate. Must only be used on the `Variable` variant of `Term` or the following `Expression` variants
    /// - A `Select` where the `iftrue` and `iffalse` are booleans.
    /// - A `FieldAccess` where the accessed field is a `bool`
    /// - An `AccessIndex` on an array of `bool`s
    /// - A `cast` to a boolean type.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// - [`ErrorCode::PoisonedLock`] if the lock on the global context is poisoned.
    /// - [`ErrorCode::InvalidTerm`] if the term does not exist in the library's collection.
    /// - [`ErrorCode::InvalidContext`] if the provided context does not exist in the library's collection.
    MaybeTerm Context::new_unit_pred(FfiTerm term) {
        return abc_new_unit_pred(*this, term);
    }

    /// Create a Term holding the `true` predicate
    MaybeTerm Context::new_literal_true() {
        return abc_new_literal_true(*this);
    }

    /// Create a Term holding the `false` predicate
    MaybeTerm Context::new_literal_false() {
        return abc_new_literal_false(*this);
    }

    /// Constructs the Predicate term `lhs && rhs`.
    ///
    /// # Arguments
    /// - `lhs`: The left-hand side of the logical and. Must be a predicate term.
    /// - `rhs`: The right-hand side of the logical and. Must be a predicate term.
    ///
    /// Use `new_unit_pred` to convert variables and expression terms to predicates that can be used in this function.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global context is poisoned.
    /// - `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the library's collection.
    /// - `ErrorCode::InvalidContext` if the provided context does not exist in the library's collection.
    MaybeTerm Context::new_logical_and(FfiTerm lhs, FfiTerm rhs) {
        return abc_new_logical_and(*this, lhs, rhs);
    }

    /// Constructs the Predicate Term `lhs || rhs`.
    ///
    /// # Arguments
    /// - `lhs`: The left-hand side of the logical or. Must be a predicate term.
    /// - `rhs`: The right-hand side of the logical or. Must be a predicate term.
    ///
    /// Use [`abc_new_unit_pred`] to convert variables and expression terms to predicates that can be used in this function.
    ///
    /// # Errors
    /// - [`ErrorCode::PoisonedLock`] if the lock on the global context is poisoned.
    /// - [`ErrorCode::InvalidTerm`] if either `lhs` or `rhs` do not exist in the library's collection.
    /// - [`ErrorCode::InvalidContext`] if the provided context does not exist in the library's collection.
    MaybeTerm Context::new_logical_or(FfiTerm lhs, FfiTerm rhs) {
        return abc_new_logical_or(*this, lhs, rhs);
    }

    /// Constructs the predicate term `lhs op rhs`
    ///
    /// # Arguments
    /// - `op`: The comparison operator to use.
    /// - `lhs`: The left-hand side of the comparison. Must be a predicate term.
    /// - `rhs`: The right-hand side of the comparison.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// - [`ErrorCode::InvalidTerm`] is returned if either `lhs` or `rhs` do not exist in the library's collection.
    /// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
    /// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
    MaybeTerm Context::new_comparison(CmpOp op, FfiTerm lhs, FfiTerm rhs) {
        return abc_new_comparison(*this, op, lhs, rhs);
    }

    /// Constructs the predicate term `!t`
    ///
    /// If `t` is already a [`Predicate::Not`], then it removes the `!`
    ///
    /// # Errors
    /// - [`ErrorCode::InvalidTerm`] is returned if `t` does not exist in the library's collection.
    /// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
    /// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
    ///
    /// [`Predicate::Not`]: crate::Predicate::Not
    MaybeTerm Context::new_not(FfiTerm t) {
        return abc_new_not(*this, t);
    }

    /// Create a new variable term, with the provided name.
    ///
    /// It is important to remember that terms must have unique names! All terms
    /// are required to use SSA naming within a context. This includes terms defined within their own summaries.
    ///
    /// # Errors
    /// - [`ErrorCode::NullPointer`] is returned if the string passed is null.
    /// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global context is poisoned.
    /// - [`ErrorCode::InvalidContext`] is returned if the provided context does not exist in the library's collection.
    MaybeTerm Context::new_var(const char *s) {
        return abc_new_var(*this, s);
    }

    /// Create a new `cast` expression. This corresponds to the `as` operator in WGSL.
    ///
    /// `source_term` is the term to cast, and `ty` is the type to cast it to.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if the term was not valid.
    ///
    /// # Errors
    /// - [`ErrorCode::PoisonedLock`] is returned if the lock on the global Terms or Types is poisoned.
    /// - [`ErrorCode::InvalidType`] is returned if `ty` is not found in the context.
    /// - [`ErrorCode::InvalidTerm`] is returned if `source_term` is not found in the context.
    /// - [`ErrorCode::WrongType`] is returned if the type passed is not a scalar type.
    MaybeTerm Context::new_cast(FfiTerm source_term, FfiAbcType ty) {
        return abc_new_cast(*this, source_term, ty);
    }

    /// Create a new comparison term, e.g. `x > y`.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid
    ///
    /// # Errors
    /// - [`ErrorCode::InvalidTerm`] is returned if either `lhs` or `rhs` do not exist in the library's collection.
    MaybeTerm Context::new_cmp_term(CmpOp op, FfiTerm lhs, FfiTerm rhs) {
        return abc_new_cmp_term(*this, op, lhs, rhs);
    }

    /// Create a new index access term, e.g. `x[y]`.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `base` or `index` do not exist in the context.
    MaybeTerm Context::new_index_access(FfiTerm base, FfiTerm index) {
        return abc_new_index_access(*this, base, index);
    }

    /// Create a new struct access term, e.g. `x.y`.
    ///
    /// # Arguments
    /// - `base`: The base term whose field is being accessed
    /// - `field`: The name of the field being accessed.
    /// - `ty`: The type of the struct being accessed. This is needed for term validation.
    /// - `field_idx`: The index of the field in the structure being accessed.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term or type could not be found.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if `base` does not exist in the context.
    /// [`ErrorCode::PoisonedLock`] is returned if the lock on the global Terms or Types container is poisoned.
    MaybeTerm Context::new_struct_access(FfiTerm base, const char *field, FfiAbcType ty, size_t field_idx) {
        return abc_new_struct_access(*this, base, field, ty, field_idx);
    }

    /// Create a new splat term, e.g. `vec3(x)`.
    ///
    /// A `splat` is just shorthand for a vector of size `size` where each element is `term`.
    ///
    /// # Arguments
    /// - `term`: The term to splat.
    /// - `size`: The number of elements in the vector. Must be between 2 and 4  (inclusive).
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if `term` does not exist in the library's collection.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::ValueError` if `size` is not between 2 and 4.
    MaybeTerm Context::new_splat(FfiTerm term, uint32_t size) {
        return abc_new_splat(*this, term, size);
    }

    /// Create a new literal term.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a new `Literal` variant of `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_literal(Literal lit) {
        return abc_new_literal(*this, lit);
    }

    /// Create a binary operation term, e.g. `x + y`.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the library's collection.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_binary_op(BinaryOp op, FfiTerm lhs, FfiTerm rhs) {
        return abc_new_binary_op(*this, op, lhs, rhs);
    }

    /// Create a new unary operation term, e.g. `-x`.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_unary_op(UnaryOp op, FfiTerm term) {
        return abc_new_unary_op(*this, op, term);
    }

    /// Create a new term corresponding to wgsl's [`max`](https://www.w3.org/TR/WGSL/#max-float-builtin) bulitin.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_max(FfiTerm lhs, FfiTerm rhs) {
        return abc_new_max(*this, lhs, rhs);
    }

    /// Create a new term corresponding to wgsl's [`min`](https://www.w3.org/TR/WGSL/#min-float-builtin) builtin.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_min(FfiTerm lhs, FfiTerm rhs) {
        return abc_new_min(*this, lhs, rhs);
    }

    /// Create a new term akin to wgsl's [`select`](https://www.w3.org/TR/WGSL/#select-builtin) bulitin.
    ///
    /// ### Note: In this method, the condition is the first argument, while it is the last argument in the WGSL builtin.
    ///
    ///
    /// # Arguments
    /// - `iftrue`: The expression this term evaluates to if `predicate` is true
    /// - `iffalse`: The expression this term evaluates to if `predicate` is false
    /// - `Predicate`: The term that determines the resolution of `iftrue` or `iffalse`.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `lhs`, `m`, or `rhs` do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_select(FfiTerm iftrue, FfiTerm iffalse, FfiTerm predicate) {
        return abc_new_select(*this, iftrue, iffalse, predicate);
    }

    /// Create a new term corresponding to wgsl's `vec2` type. This should not be confused with array types.
    ///
    /// # Arguments
    /// - `term_0`: The first term in the vector
    /// - `term_1`: The second term in the vector
    /// - `ty`: The type of the terms in the vector
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the terms do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_vec2(FfiTerm term_0, FfiTerm term_1, FfiAbcType ty) {
        return abc_new_vec2(*this, term_0, term_1, ty);
    }

    /// Create a new term corresponding to wgsl's `vec3` type. This should not be confused with array types.
    ///
    /// # Arguments
    /// - `term_0`: The first term in the vector
    /// - `term_1`: The second term in the vector
    /// - `term_3`: The third term in the vector
    /// - `ty`: The type of the terms in the vector
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the terms do not exist in the context.
    /// `ErrorCode::InvalidType` if `ty` does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_vec3(FfiTerm term_0, FfiTerm term_1, FfiTerm term_2, FfiAbcType ty) {
        return abc_new_vec3(*this, term_0, term_1, term_2, ty);
    }

    /// Create a new term corresponding to wgsl's `vec4` type. This should not be confused with array types.
    ///
    /// # Arguments
    /// - `term_0`: The first term in the vector
    /// - `term_1`: The second term in the vector
    /// - `term_2`: The third term in the vector
    /// - `term_3`: The fourth term in the vector
    /// - `ty`: The type of the terms in the vector
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the terms do not exist in the context.
    /// `ErrorCode::InvalidType` if `ty` does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_vec4(FfiTerm term_0, FfiTerm term_1, FfiTerm term_2, FfiTerm term_3, FfiAbcType ty) {
        return abc_new_vec4(*this, term_0, term_1, term_2, term_3, ty);
    }

    /// Create a new `array_length` term corresponding to the `arrayLength` operator in WGSL.
    /// Note that `wgsl` only defines this method for dynamically sized arrays. This method is
    /// not valid for fixed-sized arrays, matrices, or vectors.
    ///
    /// ### Notes
    /// Do not use this term to add a constraint on the length of an array. Instead, invoke the solver's `mark_length` method.
    /// This method is only meant to be used in the case that `arrayLength` is spelled in wgsl source.
    ///
    /// # Arguments
    /// - `term`: The array term that this expression is being applied to.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_array_length(FfiTerm term) {
        return abc_new_array_length(*this, term);
    }

    /// Create a new `store` term.
    ///
    /// There is no explicit wgsl method that this corresponds to. However, it must be used when writing to array in
    /// order to respect SSA requirements. This method creates a new term where each array element is the same as the
    /// original array, except for the element at `index`, which is `value`.
    ///
    /// # Arguments
    /// - `term`: The array term that is being written to.
    /// - `index`: The index of the array that is being written to.
    /// - `value`: The value that is being written to the array.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_array_store(FfiTerm base, FfiTerm index, FfiTerm value) {
        return abc_new_store(*this, base, index, value);
    }

    /// Create a new struct store term.
    ///
    /// There is no explicit wgsl method that this corresponds to. However, it must be used when writing to a struct in
    /// order to respect SSA requirements. This method creates a new term where each field is the same as the
    /// original struct, except for the field at `field_idx`, which is `value`.
    ///
    /// # Arguments
    /// - `term`: The struct term that is being written to.
    /// - `field_idx`: The index of the field that is being written to.
    /// - `value`: The value that is being written to the struct.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_struct_store(FfiTerm base, size_t field_idx, FfiTerm value) {
        return abc_new_struct_store(*this, base, field_idx, value);
    }

    /// Create a new absolute value term corresponding to the [`abs`](https://www.w3.org/TR/WGSL/#abs-float-builtin) operator in WGSL.
    ///
    /// # Arguments
    /// - `term`: The term that is being passed to the `abs` operator.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if `term` does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_abs(FfiTerm term) {
        return abc_new_abs(*this, term);
    }

    /// Create a new `pow` term corresponding to the [`pow`](https://www.w3.org/TR/WGSL/#pow-builtin) builtin in WGSL.
    ///
    /// # Arguments
    /// - `base`: The base of the power operation.
    /// - `exponent`: The exponent of the power operation.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `base` or `exponent` do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_pow(FfiTerm base, FfiTerm exponent) {
        return abc_new_pow(*this, base, exponent);
    }

    /// Create a new term corresponding to wgsl's [`dot`](https://www.w3.org/TR/WGSL/#dot-builtin) builtin.
    ///
    /// # Arguments
    /// - `lhs`: The left-hand side of the dot product.
    /// - `rhs`: The right-hand side of the dot product.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if either `lhs` or `rhs` do not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    MaybeTerm Context::new_dot(FfiTerm lhs, FfiTerm rhs) {
        return abc_new_dot(*this, lhs, rhs);
    }

    /// Create a new `mat2x2` term
    ///
    /// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec2`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec2`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat2x2(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty) {
        return abc_new_mat2x2(*this, row_0, row_1, ty);
    }

    /// Create a new `mat2x3` term
    ///
    /// The components of the matrix must correspond to `vec3` terms, which can be created via the `new_vec3`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec3`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat2x3(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty) {
        return abc_new_mat2x3(*this, row_0, row_1, ty);
    }

    /// Create a new `mat2x4` term
    ///
    /// The components of the matrix must correspond to `vec4` terms, which can be created via the `new_vec4`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat2x4(FfiTerm row_0, FfiTerm row_1, FfiAbcType ty) {
        return abc_new_mat2x4(*this, row_0, row_1, ty);
    }

    /// Create a new `mat3x2` term
    ///
    /// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec2`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec2`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `row_2`: The third row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat3x2(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty) {
        return abc_new_mat3x2(*this, row_0, row_1, row_2, ty);
    }

    /// Create a new `mat3x3` term
    ///
    /// The components of the matrix must correspond to `vec3` terms, which can be created via the `new_vec3`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `row_2`: The third row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat3x3(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty) {
        return abc_new_mat3x3(*this, row_0, row_1, row_2, ty);
    }

    /// Create a new `mat3x4` term
    ///
    /// The components of the matrix must correspond to `vec4` terms, which can be created via the `new_vec4`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `row_2`: The third row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat3x4(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiAbcType ty) {
        return abc_new_mat3x4(*this, row_0, row_1, row_2, ty);
    }

    /// Create a new `mat4x2` term
    ///
    /// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec3`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec3`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `row_2`: The third row of the matrix.
    /// - `row_3`: The fourth row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat4x2(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty) {
        return abc_new_mat4x2(*this, row_0, row_1, row_2, row_3, ty);
    }

    /// Create a new `mat4x3` term
    ///
    /// The components of the matrix must correspond to `vec2` terms, which can be created via the `new_vec3`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec3`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `row_2`: The third row of the matrix.
    /// - `row_3`: The fourth row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat4x3(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty) {
        return abc_new_mat4x3(*this, row_0, row_1, row_2, row_3, ty);
    }

    /// Create a new `mat4x4` term
    ///
    /// The components of the matrix must correspond to `vec4` terms, which can be created via the `new_vec4`
    /// method. A component may also be a term corresponding to a variable or expression that resolves to a `vec4`.
    ///
    /// # Arguments
    /// - `row_0`: The first row of the matrix.
    /// - `row_1`: The second row of the matrix.
    /// - `row_2`: The third row of the matrix.
    /// - `row_3`: The fourth row of the matrix.
    /// - `ty`: The type of the terms in the matrix. This must be a scalar.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either a `Term` if the term was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// `ErrorCode::InvalidTerm` if any of the rows do not exist in the context.
    /// `ErrorCode::InvalidType` if the type does not exist in the context.
    /// `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// `ErrorCode::WrongType` if the type passed is not a scalar type.
    MaybeTerm Context::new_mat4x4(FfiTerm row_0, FfiTerm row_1, FfiTerm row_2, FfiTerm row_3, FfiAbcType ty) {
        return abc_new_mat4x4(*this, row_0, row_1, row_2, row_3, ty);
    }
    /// Get the string representation of the term.
    ///
    /// If the term is invalid, `<NotFound>` is returned.
    /// Note: The returned string *must* be freed by calling `abc_free_string` or this will lead to a memory leak.
    char * Context::term_to_cstr(FfiTerm term) {
        return abc_term_to_cstr(*this, term);
    }

    /// Create a new scalar type as an `FfiAbcType` from an `AbcScalar`.
    ///
    /// # Arguments
    /// - `scalar` The constructed scalar.
    ///
    /// # Safety
    /// The caller must ensure that the `fields` and `types` pointers are not null, and that the `len`
    /// parameter is at least as long as the number of elements and fields.
    ///
    /// This method does check that the pointers are properly aligned and not null.
    /// However, the caller must ensure that the pointers hold at least `len` elements.
    /// Otherwise, behavior is undefined.
    ///
    /// # Errors
    /// - `ErrorCode::NullPointer` if either `fields` or `types` is null.
    /// - `ErrorCode::Alignmenterror` if the pointers are not properly aligned.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidType` if any of the types passed do not exist the context.
    ///
    /// Example:
    /// ```cpp
    /// context.new_Scalar_type(AbcScalar::Sint(4));
    /// ```
    MaybeAbcType Context::new_Scalar_type(AbcScalar scalar) {
        return abc_new_Scalar_type(*this, scalar);
    }

    /// Create a new struct type. Takes a list of fields, each of which is a tuple of a string and an `AbcType`.
    ///
    /// `num_fields` specifies how many fields are passed. It MUST be at least as long as the number of fields and types
    /// passed.
    ///
    /// # Safety
    /// The caller must ensure that the `fields` and `types` pointers are not null, and that the `len`
    /// parameter is at least as long as the number of elements and fields.
    ///
    /// This method does check that the pointers are properly aligned and not null.
    /// However, the caller must ensure that the pointers hold at least `len` elements.
    /// Otherwise, behavior is undefined.
    ///
    /// # Errors
    /// - `ErrorCode::NullPointer` if either `fields` or `types` is null.
    /// - `ErrorCode::Alignmenterror` if the pointers are not properly aligned.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidType` if any of the types passed do not exist the context.
    MaybeAbcType Context::new_Struct_type(const char* *fields, const FfiAbcType *types, size_t num_fields) {
        return abc_new_Struct_type(*this, fields, types, num_fields);
    }
    /// Declare a new `SizedArray` type. `size` is the number of elements in the array. This cannot be 0.
    ///
    /// # Errors
    /// - `ErrorCode::InvalidType` is returned if the type passed does not exist in the context.
    /// - `ErrorCode::PoisonedLock` is returned if the lock on the global contexts is poisoned.
    /// - `ErrorCode::ForbiddenZero` is returned if the size is 0.
    MaybeAbcType Context::new_SizedArray_type(FfiAbcType ty, uint32_t size) {
        return abc_new_SizedArray_type(*this, ty, size);
    }

    /// Declare a new Dynamic Array type of the elements of the type passed.
    ///
    /// # Errors
    /// - `ErrorCode::InvalidType` is returned if the type passed does not exist in the context.
    /// - `ErrorCode::PoisonedLock` is returned if the lock on the global contexts is poisoned.
    /// - `ErrorCode::ForbiddenZero` is returned if the size is 0.
    MaybeAbcType Context::new_DynamicArray_type(FfiAbcType ty) {
        return abc_new_DynamicArray_type(*this, ty);
    }



    /// Solve the constraints for the provided summary.
    ///
    /// Note that the returned solution *must be freed* by calling `abc_free_solution` otherwise
    /// a memory leak will occur.
    ///
    /// This will return an `FfiSolution` which contains the results.
    /// The results are in the form (id, bool). `id` corresponds to the
    /// id of the constraint that was provided when the constraint was added.
    /// the `bool` corresponds to the result of the constraint. It is `true`
    /// if the constraint is always satisfied. In this case, the bounds check
    /// can be removed. `false` means that the constraint could not
    /// be proven to always be satisfied. In this case, the bounds check
    /// must be kept.
    ///
    /// In this current implementation, there is not a distinction
    /// between checks that are always violated and checks that may be violated.
    ///
    ///
    /// # Errors
    /// - `SolverErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `SolverErrorCode::InvalidContext` if the context does not exist.
    /// - `SolverErrorCode::InvalidSummary` if the summary does not exist in the context.
    /// - Many other errors may be returned that occur during the solving process.
    MaybeSolution Context::solve_constraints(FfiSummary summary) {
        return abc_solve_constraints(*this, summary);
    }

    /// Serializes the constraint system to json.
    /// The input should be a file path where the serialized json will be written.
    ErrorCode Context::serialize_constraints(const char* path) {
        return abc_serialize_constraints(*this, path);
    }

    /// Mark a variable as a loop variable.
    ///
    /// A loop variable is any variable that is updated within a loop. Supported operations
    /// are limited to binary operations. For best results, the increment / decrement term must be
    /// a constnat.
    ///
    /// # Arguments
    /// - `var`: The induction variable.
    /// - `init`: The expression the induction variable is initialized to.
    /// - `update_rhs`: The expression that the term is incremented / decremented by
    /// - `update_op`: The operation that is used to update the term.
    ///
    /// Note that `inc_term` and `inc_op` are parts of the expression with the induction term.
    /// That is, only expressions of the form `a = a op b` are allowed, where `a` is the induction variable.
    /// This method should come **before** the `begin_loop` call.
    ///
    /// # Errors
    /// - `ErrorCode::InvalidTerm` if any of the terms passed are invalid.
    /// - `ErrorCode::UnsupportedOperation` if the operation is not supported for loops.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    ErrorCode Context::mark_loop_variable(FfiTerm var, FfiTerm init, FfiTerm update_rhs, BinaryOp update_op) {
        return abc_mark_loop_variable(*this, var, init, update_rhs, update_op);
    }

    /// Add the constraints of the summary by invoking the function call with the proper arguments.
    ///
    ///
    /// # Arguments
    /// - `summary`: The summary for the function being invoked
    /// - `args`: An array containing the arguments that are passed to the function.
    /// - `num_args`: The size of the `args` array.
    /// - `return_dest`: A fresh variable term that will hold the return value. If the return value is not used,
    /// then this must be the `Empty` term.
    ///
    /// This will add the constraints of the summary to the constraint system, with
    /// the arguments substituted with `args`, and the return value substituted with `return_dest`.
    ///
    /// # Safety
    /// The caller must ensure that `args` holds at least `num_args` elements.
    ///
    /// # Errors
    /// - `ErrorCode::NullPointer` if `args` is null and `num_args` is not 0.
    /// - `ErrorCode::AlignmentError` if `args` is not properly aligned.
    /// - `ErrorCode::InvalidTerm` if any of the terms passed do not exist in the context.
    /// - `ErrorCode::InvalidSummary` if the summary does not exist in the context.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    MaybeTerm Context::new_call(FfiSummary summary, const FfiTerm *args, uint32_t num_args, FfiTerm return_dest) {
        return abc_new_call(*this, summary, args, num_args, return_dest);
    }

    /// Begins a loop context.
    ///
    /// A loop context is akin to a predicate context. It allows for the convenience methods for `break` and `continue`
    /// to be properly handled. Additionally, all updates to variables within are marked as range constraints.
    ///
    /// The `condition` should correspond to a boolean term where one of the operands has been marked as a loop variable.
    ///
    /// # Errors
    /// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
    /// - `ErrorCode::UnsupportedLoopCondition` if the condition is not a `Predicate` or `Var` term.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    ErrorCode Context::begin_loop(FfiTerm condition) {
        return abc_begin_loop(*this, condition);
    }

    /// End a loop context.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::NotInLoopcontext` if there has been no matching call to `begin_loop`.
    ErrorCode Context::end_loop() {
        return abc_end_loop(*this);
    }

    /// Mark an assumption.
    ///
    /// Assumptions are invariants that must hold at all times.
    /// At solving time, these differ from constraints in that they are not inverted
    /// to test for satisfiability.
    ///
    /// # Arguments
    /// - `lhs`: The left hand side of the assumption.
    /// - `op`: The operation that is used to compare the terms.
    /// - `rhs`: The right hand side of the assumption.
    ///
    /// There can only be one assumption per direction for each term. That is,
    /// each term may *either* have one equality assumption (:=) *or* one
    ///  inequality assumption per direction (one less / less equal, one
    /// greater / greater equal). Violating this will result in a
    /// `DuplicateAssumption` error.
    ///
    /// # Errors
    /// - `ErrorCode::InvalidTerm` if any term does not exist in the context.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::DuplicateAssumption` if `lhs` has already had an assumption on the specified boundary.
    ErrorCode Context::add_assumption(FfiTerm lhs, AssumptionOp op, FfiTerm rhs) {
        return abc_add_assumption(*this, lhs, op, rhs);
    }

    /// Begin a summary block.
    ///
    /// A summary block corresponds to a function definition. All constraints
    /// that are added within the summary block are considered to be constraints
    /// of the function.
    ///
    /// A summary block must be ended with a call to `end_summary`, which will
    /// provide the `FfiSummary` that can be used to refer to it.
    ///
    /// # Arguments
    /// - `name`: The name of the function.
    /// - `num_args`: The number of arguments the function takes.
    ///
    /// # Errors
    /// - `ErrorCode::NullPointer` if `name` is null.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::SummaryLimitExceeded` if the number of summaries exceeds the limit.
    ErrorCode Context::begin_summary(const char* name, uint8_t num_args) {
        return abc_begin_summary(*this, name, num_args);
    }

    /// End a summary block.
    ///
    /// This will return the `FfiSummary` that can be used to refer to the summary.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::NotInSummary` if there has been no matching call to `begin_summary`.
    MaybeSummary Context::end_summary() {
        return abc_end_summary(*this);
    }

    /// Add an argument to the active summary.
    ///
    /// The `begin_summary` method must be called before this method.
    ///
    /// # Arguments
    /// - `name`: The name of the argument.
    /// - `ty`: The type of the argument.
    ///
    /// # Returns
    /// A `MaybeTerm` which is either an `FfiTerm` if the argument was successfully created, or an `ErrorCode` if a provided term was invalid.
    ///
    /// # Errors
    /// - `ErrorCode::NullPointer` if `name` is null.
    /// - `ErrorCode::InvalidType` if the type does not exist in the context.
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::NotInSummary` if there has been no matching call to `begin_summary`.
    MaybeTerm Context::add_argument(const char* name, FfiAbcType ty) {
        return abc_add_argument(*this, name, ty);
    }

    /// Mark a break statement. (Currently unimplemented)
    ///
    /// # Errors
    /// `ConstraintError::NotImplemented`
    ErrorCode Context::mark_break() {
        return abc_mark_break(*this);
    }

    /// Mark a continue statement. (Currently unimplemented)
    ///
    /// # Errors
    /// `ConstraintError::NotImplemented`
    ErrorCode Context::mark_continue() {
        return abc_mark_continue(*this);
    }

    /// Mark the type of the provided term.
    ///
    /// # Errors
    /// [`DuplicateType`] if the type of the term has already been marked.
    ///
    /// [`DuplicateType`]: crate::ConstraintError::DuplicateType
    ErrorCode Context::mark_type(FfiTerm term, FfiAbcType ty) {
        return abc_mark_type(*this, term, ty);
    }

    /// Begin a predicate block. This indicates to the solver
    /// that all expressions that follow can be filtered by the predicate.
    /// Any constraint that falls within a predicate becomes a soft constraint
    ///
    /// In other words, it would be as if all constraints were of the form
    /// ``p -> c``
    /// Nested predicate blocks end up composing the predicates. E.g.,
    /// ``begin_predicate_block(p1)`` followed by ``begin_predicate_block(p2)``
    /// would mark all constraints as ``p1 && p2 -> c``
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    ErrorCode Context::begin_predicate_block(FfiTerm predicate) {
        return abc_begin_predicate_block(*this, predicate);
    }

    /// End the active predicate block.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::PredicateStackEmpty` if there is no active predicate block.
    ErrorCode Context::end_predicate_block() {
        return abc_end_predicate_block(*this);
    }

    /// Add a constraint to the system that narrows the domain of `term`.
    ///
    /// Any active predicates are automatically applied.
    ///
    /// There can only be one constraint per boundary side for each term. That is,
    /// each term may *either* have one equality constraint (:=) *or* one
    /// inequality constraint per side (one less / less equal, one
    /// greater / greater equal). Violating this will result in a
    /// `DuplicateConstraint` error.
    ///
    /// # Arguments
    /// - `lhs`: The left hand side of the constraint.
    /// - `op`: The operation of the constraint.
    /// - `rhs`: The right hand side of the constraint.
    /// - `id`: The identifier that the constraint system will use to refer to
    /// the constraint. Results will reference this id.
    ///
    ///
    /// # Errors
    /// - `TypeMismatch` if the type of `term` is different from the type of
    /// `rhs` and `op` is `ConstraintOp::Assign`
    /// - `MaxConstraintCountExceeded` if the maximum number of constraints has
    /// been exceeded.
    ErrorCode Context::add_constraint(FfiTerm lhs, ConstraintOp op, FfiTerm rhs, uint32_t id) {
        return abc_add_constraint(*this, lhs, op, rhs, id);
    }

    /// Mark a return statement.
    ///
    /// # Arguments
    /// - `retval`: The term that corresponds to the return value. If no value
    /// is returned, this *must* be the `Empty` term.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    ErrorCode Context::mark_return(FfiTerm retval) {
        return abc_mark_return(*this, retval);
    }

    /// Mark the length of an array's dimension. Only valid for dynamically
    /// sized arrays.
    ///
    ///
    /// It is *strongly* preferred to use the type system to mark the variable as
    /// a `SizedArray` type.
    /// This should *only* be used for dynamic arrays whose size is determined later.
    ///
    /// # Arguments
    /// - `term`: The array term to mark the dimension of
    /// - `dim`: The term that corresponds to the 0-based dimension of the array.
    /// - `size`: The size of the array.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    ErrorCode Context::mark_array_length(FfiTerm term, uint8_t dim, uint32_t size) {
        return abc_mark_array_length(*this, term, dim, size);
    }
    
    /// Mark the range of a runtime constant. Sugar for a pair of assumptions
    /// (var >= min) and (var <= max).
    ///
    /// The `lower` and `upper` terms must be literals of the same type.
    ///
    /// ## Notes
    /// - The current predicate block is ignored, though the constraints *are*
    /// added to the active summary (or global if no summary is active)
    /// - This is not meant to be used for loop variables.
    /// Use `mark_loop_variable` for that.
    ///
    /// # Arguments
    /// - `term`: The term to mark the range of.
    /// - `lower`: The lower bound of the range.
    /// - `upper`: The upper bound of the range.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidTerm` if the term does not exist in the context.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::WrongType` if the two literals are not the same variant.
    ErrorCode Context::mark_range(FfiTerm term, Literal lower, Literal upper) {
        return abc_mark_range(*this, term, lower, upper);
    }

    /// Mark the return type for the active summary.
    ///
    /// It is not necessary to call this method for functions that do not return
    /// a value.
    ///
    /// # Errors
    /// - `ErrorCode::PoisonedLock` if the lock on the global contexts is poisoned.
    /// - `ErrorCode::InvalidContext` if the context does not exist.
    /// - `ErrorCode::InvalidSummary` if there is no active summary
    /// - `ErrorCode::DuplicateType` if the return type has already been marked for the summary
    ErrorCode Context::mark_return_type(FfiAbcType ty) {
        return abc_mark_return_type(*this, ty);
    }

    FfiTerm Context::get_empty_term() {
        return abc_get_empty_term();
    }

    inline std::ostream& operator<<(std::ostream& os, SolverResult result) {
        switch (result) {
          case SolverResult::Yes: os << "Yes"; break;
          case SolverResult::Maybe: os << "Maybe"; break;
          case SolverResult::No: os << "No"; break;
        }
        return os;
      }
}
